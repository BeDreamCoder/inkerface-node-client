// This file is auto generated by the protocol-buffers cli tool

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

exports.ConfidentialityLevel = {
  "PUBLIC": 0,
  "CONFIDENTIAL": 1
}

var ChaincodeID = exports.ChaincodeID = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ChaincodeInput = exports.ChaincodeInput = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ChaincodeSpec = exports.ChaincodeSpec = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SenderSpec = exports.SenderSpec = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var SignContent = exports.SignContent = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ChaincodeInvocationSpec = exports.ChaincodeInvocationSpec = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineChaincodeID()
defineChaincodeInput()
defineChaincodeSpec()
defineSenderSpec()
defineSignContent()
defineChaincodeInvocationSpec()

function defineChaincodeID () {
  var enc = [
    encodings.string
  ]

  ChaincodeID.encodingLength = encodingLength
  ChaincodeID.encode = encode
  ChaincodeID.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.path)) {
      var len = enc[0].encodingLength(obj.path)
      length += 1 + len
    }
    if (defined(obj.name)) {
      var len = enc[0].encodingLength(obj.name)
      length += 1 + len
    }
    if (defined(obj.version)) {
      var len = enc[0].encodingLength(obj.version)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.path)) {
      buf[offset++] = 10
      enc[0].encode(obj.path, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.name)) {
      buf[offset++] = 18
      enc[0].encode(obj.name, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.version)) {
      buf[offset++] = 26
      enc[0].encode(obj.version, buf, offset)
      offset += enc[0].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      path: "",
      name: "",
      version: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.path = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 2:
        obj.name = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 3:
        obj.version = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineChaincodeInput () {
  var enc = [
    encodings.bytes
  ]

  ChaincodeInput.encodingLength = encodingLength
  ChaincodeInput.encode = encode
  ChaincodeInput.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        var len = enc[0].encodingLength(obj.args[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.args)) {
      for (var i = 0; i < obj.args.length; i++) {
        if (!defined(obj.args[i])) continue
        buf[offset++] = 10
        enc[0].encode(obj.args[i], buf, offset)
        offset += enc[0].encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      args: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.args.push(enc[0].decode(buf, offset))
        offset += enc[0].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineChaincodeSpec () {
  ChaincodeSpec.Type = {
  "UNDEFINED": 0,
  "GOLANG": 1,
  "NODE": 2,
  "CAR": 3,
  "JAVA": 4
}

  var enc = [
    encodings.enum,
    ChaincodeID,
    ChaincodeInput,
    encodings.int32
  ]

  ChaincodeSpec.encodingLength = encodingLength
  ChaincodeSpec.encode = encode
  ChaincodeSpec.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.type)) {
      var len = enc[0].encodingLength(obj.type)
      length += 1 + len
    }
    if (defined(obj.chaincode_id)) {
      var len = enc[1].encodingLength(obj.chaincode_id)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.input)) {
      var len = enc[2].encodingLength(obj.input)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.timeout)) {
      var len = enc[3].encodingLength(obj.timeout)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.type)) {
      buf[offset++] = 8
      enc[0].encode(obj.type, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.chaincode_id)) {
      buf[offset++] = 18
      varint.encode(enc[1].encodingLength(obj.chaincode_id), buf, offset)
      offset += varint.encode.bytes
      enc[1].encode(obj.chaincode_id, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.input)) {
      buf[offset++] = 26
      varint.encode(enc[2].encodingLength(obj.input), buf, offset)
      offset += varint.encode.bytes
      enc[2].encode(obj.input, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.timeout)) {
      buf[offset++] = 32
      enc[3].encode(obj.timeout, buf, offset)
      offset += enc[3].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      type: 0,
      chaincode_id: null,
      input: null,
      timeout: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.type = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.chaincode_id = enc[1].decode(buf, offset, offset + len)
        offset += enc[1].decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.input = enc[2].decode(buf, offset, offset + len)
        offset += enc[2].decode.bytes
        break
        case 4:
        obj.timeout = enc[3].decode(buf, offset)
        offset += enc[3].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSenderSpec () {
  var enc = [
    encodings.bytes,
    encodings.varint
  ]

  SenderSpec.encodingLength = encodingLength
  SenderSpec.encode = encode
  SenderSpec.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.sender)) {
      var len = enc[0].encodingLength(obj.sender)
      length += 1 + len
    }
    if (defined(obj.counter)) {
      var len = enc[1].encodingLength(obj.counter)
      length += 1 + len
    }
    if (defined(obj.ink_limit)) {
      var len = enc[0].encodingLength(obj.ink_limit)
      length += 1 + len
    }
    if (defined(obj.msg)) {
      var len = enc[0].encodingLength(obj.msg)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.sender)) {
      buf[offset++] = 10
      enc[0].encode(obj.sender, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.counter)) {
      buf[offset++] = 16
      enc[1].encode(obj.counter, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.ink_limit)) {
      buf[offset++] = 26
      enc[0].encode(obj.ink_limit, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.msg)) {
      buf[offset++] = 34
      enc[0].encode(obj.msg, buf, offset)
      offset += enc[0].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      sender: null,
      counter: 0,
      ink_limit: null,
      msg: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.sender = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 2:
        obj.counter = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 3:
        obj.ink_limit = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 4:
        obj.msg = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSignContent () {
  var enc = [
    ChaincodeSpec,
    encodings.string,
    SenderSpec
  ]

  SignContent.encodingLength = encodingLength
  SignContent.encode = encode
  SignContent.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.chaincode_spec)) {
      var len = enc[0].encodingLength(obj.chaincode_spec)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.id_generation_alg)) {
      var len = enc[1].encodingLength(obj.id_generation_alg)
      length += 1 + len
    }
    if (defined(obj.sender_spec)) {
      var len = enc[2].encodingLength(obj.sender_spec)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.chaincode_spec)) {
      buf[offset++] = 10
      varint.encode(enc[0].encodingLength(obj.chaincode_spec), buf, offset)
      offset += varint.encode.bytes
      enc[0].encode(obj.chaincode_spec, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.id_generation_alg)) {
      buf[offset++] = 18
      enc[1].encode(obj.id_generation_alg, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.sender_spec)) {
      buf[offset++] = 26
      varint.encode(enc[2].encodingLength(obj.sender_spec), buf, offset)
      offset += varint.encode.bytes
      enc[2].encode(obj.sender_spec, buf, offset)
      offset += enc[2].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      chaincode_spec: null,
      id_generation_alg: "",
      sender_spec: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.chaincode_spec = enc[0].decode(buf, offset, offset + len)
        offset += enc[0].decode.bytes
        break
        case 2:
        obj.id_generation_alg = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.sender_spec = enc[2].decode(buf, offset, offset + len)
        offset += enc[2].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineChaincodeInvocationSpec () {
  var enc = [
    ChaincodeSpec,
    encodings.string,
    SenderSpec,
    encodings.bytes
  ]

  ChaincodeInvocationSpec.encodingLength = encodingLength
  ChaincodeInvocationSpec.encode = encode
  ChaincodeInvocationSpec.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.chaincode_spec)) {
      var len = enc[0].encodingLength(obj.chaincode_spec)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.id_generation_alg)) {
      var len = enc[1].encodingLength(obj.id_generation_alg)
      length += 1 + len
    }
    if (defined(obj.sender_spec)) {
      var len = enc[2].encodingLength(obj.sender_spec)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.sig)) {
      var len = enc[3].encodingLength(obj.sig)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.chaincode_spec)) {
      buf[offset++] = 10
      varint.encode(enc[0].encodingLength(obj.chaincode_spec), buf, offset)
      offset += varint.encode.bytes
      enc[0].encode(obj.chaincode_spec, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.id_generation_alg)) {
      buf[offset++] = 18
      enc[1].encode(obj.id_generation_alg, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.sender_spec)) {
      buf[offset++] = 26
      varint.encode(enc[2].encodingLength(obj.sender_spec), buf, offset)
      offset += varint.encode.bytes
      enc[2].encode(obj.sender_spec, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.sig)) {
      buf[offset++] = 34
      enc[3].encode(obj.sig, buf, offset)
      offset += enc[3].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      chaincode_spec: null,
      id_generation_alg: "",
      sender_spec: null,
      sig: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.chaincode_spec = enc[0].decode(buf, offset, offset + len)
        offset += enc[0].decode.bytes
        break
        case 2:
        obj.id_generation_alg = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.sender_spec = enc[2].decode(buf, offset, offset + len)
        offset += enc[2].decode.bytes
        break
        case 4:
        obj.sig = enc[3].decode(buf, offset)
        offset += enc[3].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
